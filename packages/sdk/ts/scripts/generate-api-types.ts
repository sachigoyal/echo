#!/usr/bin/env tsx
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Script to generate API types from the control app and copy them to the SDK
 * This script:
 * 1. Runs the generate-api-types command in the control app
 * 2. Copies the resolved API types to the SDK
 * 3. Creates a clean api-types.ts file for SDK consumption
 */

const CONTROL_APP_PATH = '../../../app/control';
const RESOLVED_TYPES_FILE = 'src/generated/api-types-resolved.ts';
const SDK_OUTPUT_FILE = 'src/api-types.ts';

interface ScriptOptions {
  verbose?: boolean;
  skipGeneration?: boolean;
}

/**
 * Parse command line arguments
 */
function parseArgs(): ScriptOptions {
  const args = process.argv.slice(2);
  return {
    verbose: args.includes('--verbose') || args.includes('-v'),
    skipGeneration: args.includes('--skip-generation'),
  };
}

/**
 * Log message if verbose mode is enabled
 */
function log(message: string, options: ScriptOptions): void {
  if (options.verbose) {
    ``;
    console.log(`[generate-api-types] ${message}`);
  }
}

/**
 * Generate API types in the control app
 */
function generateControlAppTypes(options: ScriptOptions): void {
  if (options.skipGeneration) {
    log('Skipping API type generation (--skip-generation flag)', options);
    return;
  }

  log('Generating API types in control app...', options);

  try {
    const controlAppPath = path.resolve(__dirname, CONTROL_APP_PATH);

    // Check if control app exists
    if (!fs.existsSync(controlAppPath)) {
      throw new Error(`Control app not found at: ${controlAppPath}`);
    }

    // Ensure Prisma is generated first
    log('Generating Prisma client...', options);
    execSync('pnpm prisma:generate', {
      cwd: controlAppPath,
      stdio: options.verbose ? 'inherit' : 'pipe',
      timeout: 60000, // 60 second timeout
      encoding: 'utf8',
    });

    // Run the generate-api-types command
    log('Running generate-api-types in control app...', options);
    execSync('npm run generate-api-types', {
      cwd: controlAppPath,
      stdio: options.verbose ? 'inherit' : 'pipe',
      timeout: 120000, // 120 second timeout
      encoding: 'utf8',
    });

    log('‚úÖ Successfully generated API types in control app', options);
  } catch (error) {
    console.error('‚ùå Failed to generate API types in control app:', error);
    process.exit(1);
  }
}

/**
 * Copy and clean the resolved types for SDK consumption
 */
function copyResolvedTypes(options: ScriptOptions): void {
  log('Copying resolved API types to SDK...', options);

  try {
    const controlAppPath = path.resolve(__dirname, CONTROL_APP_PATH);
    const resolvedTypesPath = path.join(controlAppPath, RESOLVED_TYPES_FILE);
    const sdkOutputPath = path.resolve(__dirname, '..', SDK_OUTPUT_FILE);

    // Check if resolved types file exists
    if (!fs.existsSync(resolvedTypesPath)) {
      throw new Error(`Resolved types file not found at: ${resolvedTypesPath}`);
    }

    // Read the resolved types file
    const resolvedTypesContent = fs.readFileSync(resolvedTypesPath, 'utf8');

    // Create SDK-friendly content with additional header
    const sdkContent = `// Auto-generated API response types for Echo TypeScript SDK
// This file is generated by running: npm run generate-api-types
// Source: ${path.relative(process.cwd(), resolvedTypesPath)}
// Do not edit this file manually - it will be overwritten

${resolvedTypesContent
  .replace(/^\/\/ Auto-generated.*?\n/, '')
  .replace(/^\/\/ This file.*?\n/, '')
  .replace(/^\/\/ These types.*?\n/, '')
  .replace(/^\/\/ Do not edit.*?\n/, '')
  .replace(/^\n+/, '')}`;

    // Ensure the SDK src directory exists
    const sdkSrcDir = path.dirname(sdkOutputPath);
    if (!fs.existsSync(sdkSrcDir)) {
      fs.mkdirSync(sdkSrcDir, { recursive: true });
    }

    // Write the SDK types file
    fs.writeFileSync(sdkOutputPath, sdkContent, 'utf8');

    log(
      `‚úÖ Successfully copied API types to: ${path.relative(process.cwd(), sdkOutputPath)}`,
      options
    );

    // Count the number of types
    const typeCount = (sdkContent.match(/^export (interface|type)/gm) || [])
      .length;
    log(`üìù Generated ${typeCount} API types for SDK`, options);
  } catch (error) {
    console.error('‚ùå Failed to copy resolved types to SDK:', error);
    process.exit(1);
  }
}

/**
 * Validate that the generated types are valid TypeScript
 */
function validateGeneratedTypes(options: ScriptOptions): void {
  log('Validating generated types...', options);

  try {
    const sdkOutputPath = path.resolve(__dirname, '..', SDK_OUTPUT_FILE);

    if (!fs.existsSync(sdkOutputPath)) {
      throw new Error(`Generated types file not found at: ${sdkOutputPath}`);
    }

    // Basic validation - check that the file contains export statements
    const content = fs.readFileSync(sdkOutputPath, 'utf8');

    if (
      !content.includes('export interface') &&
      !content.includes('export type')
    ) {
      throw new Error(
        'Generated types file does not contain any exported types'
      );
    }

    // Check for common issues
    if (content.includes('import(')) {
      console.warn(
        '‚ö†Ô∏è  Generated types may contain unresolved import statements'
      );
    }

    log('‚úÖ Generated types validation passed', options);
  } catch (error) {
    console.error('‚ùå Generated types validation failed:', error);
    process.exit(1);
  }
}

/**
 * Main function
 */
async function main(): Promise<void> {
  const options = parseArgs();

  console.log('üîß Generating API types for Echo TypeScript SDK...');

  if (options.verbose) {
    console.log('Options:', options);
    console.log('Working directory:', process.cwd());
    console.log('Script directory:', __dirname);
  }

  // Step 1: Generate API types in control app
  generateControlAppTypes(options);

  // Step 2: Copy resolved types to SDK
  copyResolvedTypes(options);

  // Step 3: Validate generated types
  validateGeneratedTypes(options);

  console.log('üéâ Successfully generated API types for SDK!');
  console.log(`üìÑ Types available at: ${SDK_OUTPUT_FILE}`);
}

// Run the script
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('‚ùå Script failed:', error);
    process.exit(1);
  });
}

export {
  main,
  parseArgs,
  generateControlAppTypes,
  copyResolvedTypes,
  validateGeneratedTypes,
};
